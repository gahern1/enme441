# ============================================================
#  FULL WEB + SLIDER + STEPPER CONTROL SYSTEM (Self-contained)
#  Partners: Glen & Lucas
# ============================================================

import RPi.GPIO as GPIO
import socket
from urllib.parse import parse_qs
import multiprocessing
import time
from shifter import Shifter     # this must exist in directory

# ============================================================
#   STEPPER CLASS (fully included, no external import needed)
# ============================================================

class Stepper:
    num_steppers = 0
    shifter_outputs = 0
    seq = [0b0001,0b0011,0b0010,0b0110,0b0100,0b1100,0b1000,0b1001]
    delay = 1200
    steps_per_degree = 4096/360.0   # steps per degree (float)

    def __init__(self, shifter, lock):
        self.s = shifter
        self.angle = multiprocessing.Value('d', 0.0)  # shared absolute angle in degrees [0,360)
        self.step_state = 0
        self.shifter_bit_start = 4 * Stepper.num_steppers
        self.lock = lock
        Stepper.num_steppers += 1

    def __sgn(self, x):
        return 0 if x == 0 else int(abs(x)/x)

    def __step(self, direction):
        """Perform one sequence step (direction = +1 or -1) and update shared angle."""
        self.step_state = (self.step_state + direction) % 8

        # Update the global shift-register outputs for all motors
        Stepper.shifter_outputs &= ~(0b1111 << self.shifter_bit_start)
        Stepper.shifter_outputs |= (Stepper.seq[self.step_state] << self.shifter_bit_start)

        # Write to the shift register hardware
        self.s.shiftByte(Stepper.shifter_outputs)

        # Update the shared angle (add small increment per step)
        with self.angle.get_lock():
            # Each sequence step corresponds to 1 "step", so add 1 / steps_per_degree degrees
            self.angle.value = (self.angle.value + direction / Stepper.steps_per_degree) % 360.0

    def __rotate(self, delta):
        """
        Rotate by *delta* degrees in the direction implied by sign(delta).
        This routine executes in a separate process.
        """
        # number of discrete steps to take (use round to avoid truncation artifacts)
        num_steps = int(round(Stepper.steps_per_degree * abs(delta)))
        direction = self.__sgn(delta)

        for _ in range(num_steps):
            self.__step(direction)
            time.sleep(Stepper.delay / 1e6)

    def rotate(self, delta):
        """Start a process that rotates the motor by delta degrees (may be forward-only delta)."""
        p = multiprocessing.Process(target=self.__rotate, args=(delta,))
        p.start()
        return p

    # =====================================================
    #   goAngle: FORWARD-ONLY (no reversing mid-move)
    # =====================================================
    def goAngle(self, target_angle):
        """
        Rotate to an absolute target angle.
        This implementation ALWAYS moves in the forward direction (increasing angle),
        using wrap-around to go past 360 if necessary. It will NOT reverse direction.
        """

        # normalize the input target angle to [0,360)
        target_angle = float(target_angle) % 360.0

        with self.angle.get_lock():
            current = float(self.angle.value)

        # Compute forward-only delta using modulo arithmetic: this yields a value in [0,360)
        delta = (target_angle - current) % 360.0

        # For debugging: compute how many discrete steps will be executed
        num_steps = int(round(Stepper.steps_per_degree * abs(delta)))

        # DEBUG PRINT ‚Äî shows exactly what will be commanded to the motor
        print(f"[DEBUG] goAngle: current={current:.4f}¬∞, target={target_angle:.4f}¬∞, delta={delta:.4f}¬∞, num_steps={num_steps}")

        return self.rotate(delta)

    def zero(self):
        with self.angle.get_lock():
            self.angle.value = 0.0


# ============================================================
#   SETUP SHIFT REGISTER + MOTORS
# ============================================================

GPIO.setmode(GPIO.BCM)

s = Shifter(data=16, latch=20, clock=21)
lock = multiprocessing.Lock()

m1 = Stepper(s, lock)
m2 = Stepper(s, lock)

m1.zero()
m2.zero()

slider_vals = [0, 0]  # Motor1 slider, Motor2 slider


# ============================================================
#   HTML PAGE
# ============================================================

def html_page():
    return f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Stepper Controller</title>
  <style>
    body {{ font-family: Arial; text-align: center; margin-top: 40px; }}
    .slider-container {{ margin: 25px auto; width: 300px; }}
    input[type=range] {{ width: 100%; }}
  </style>
</head>
<body>

<h2>Stepper Motor Angle Controller</h2>

<div class="slider-container">
  <label>Motor 1 Angle</label><br>
  <input type="range" min="0" max="100" value="{slider_vals[0]}" id="motor0" oninput="updateMotor(0)">
  <span id="val0">{slider_vals[0]}</span>
</div>

<div class="slider-container">
  <label>Motor 2 Angle</label><br>
  <input type="range" min="0" max="100" value="{slider_vals[1]}" id="motor1" oninput="updateMotor(1)">
  <span id="val1">{slider_vals[1]}</span>
</div>

<script>
function updateMotor(idx) {{
    let val = document.getElementById("motor" + idx).value;
    document.getElementById("val" + idx).innerHTML = val;

    fetch("/", {{
      method: "POST",
      headers: {{ "Content-Type": "application/x-www-form-urlencoded" }},
      body: "motor=" + idx + "&level=" + val
    }});
}}
</script>

</body>
</html>"""


# ============================================================
#   GET IP FOR WEBPAGE LINK
# ============================================================

def get_ip_address():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
    except:
        ip = "127.0.0.1"
    finally:
        s.close()
    return ip


# ============================================================
#   START WEB SERVER
# ============================================================

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('', 8080))
server.listen(1)

print(f"üåê Control motors at: http://{get_ip_address()}:8080")

try:
    while True:
        conn, addr = server.accept()
        request = conn.recv(4096).decode()

        if not request:
            conn.close()
            continue

        if "POST" in request:
            body = request.split("\r\n\r\n")[-1]
            params = parse_qs(body)

            if "motor" in params and "level" in params:
                motor_idx = int(params["motor"][0])
                level = int(params["level"][0])

                slider_vals[motor_idx] = level
                target_angle = (level / 100.0) * 360.0

                motor = m1 if motor_idx == 0 else m2

                # Start movement and wait for it to complete
                p = motor.goAngle(target_angle)
                p.join()

                print(f"Motor {motor_idx+1} ‚Üí {target_angle:.2f}¬∞")

        conn.sendall(("HTTP/1.1 200 OK\nContent-Type: text/html\n\n" + html_page()).encode())
        conn.close()

except KeyboardInterrupt:
    print("\nShutting Down...")
    GPIO.cleanup()
    server.close()
