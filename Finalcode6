#!/usr/bin/env python3
# ============================================================
# IoT Laser Turret â€” Final (fixed)
# - Motor 1 (AZ) -> shift register bits 4-7
# - Motor 2 (EL) -> shift register bits 0-3
# - Threaded motor loops (no multiprocessing)
# - goAngle uses shortest-path immediately (no extra rotations)
# - JSON targeting + laser firing included
# ============================================================

import RPi.GPIO as GPIO
import socket
from urllib.parse import parse_qs
import time
from shifter import Shifter
import json
import urllib.request
import math
import threading
import sys

# ==================== CONFIG ====================
TEAM_ID = 14                 # <-- your team number
POSITIONS_URL = "http://192.168.1.254:8000/positions.json"
LASER_PIN = 18               # BCM pin used to switch laser (via transistor or resistor)
LASER_FIRE_DURATION = 3.0    # seconds laser is on for each firing event
TARGET_TOLERANCE_DEG = 1.0   # tolerance used to decide motor has reached target
MOTOR_STEP_DELAY_US = 1200   # microseconds delay between microsteps (controls speed/torque)
# =================================================

# ============================================================
# Stepper class (threaded motor loop, explicit bit_start mapping)
# - bit_start is the LSB index in the 8-bit shift register where this motor's 4 bits begin.
#   e.g., bit_start=4 -> uses bits 4,5,6,7; bit_start=0 -> uses bits 0,1,2,3
# - steps are integer micro-steps; steps_per_degree used to convert to/from degrees
# ============================================================

class Stepper:
    seq = [0b0001, 0b0011, 0b0010, 0b0110, 0b0100, 0b1100, 0b1000, 0b1001]
    steps_per_degree = 4096.0 / 360.0  # 4096 steps per revolution example (adjust if different)

    # global shifter output cached so multiple steppers can combine their nybbles
    shifter_outputs = 0
    shifter_lock = threading.Lock()  # protects Stepper.shifter_outputs and actual shifting

    def __init__(self, shifter, bit_start, name=""):
        """
        shifter : Shifter instance with .shiftByte(byte)
        bit_start : integer 0..4 (start bit index for the 4-bit motor field)
        name : optional label for debugging
        """
        self.s = shifter
        self.bit_start = int(bit_start)
        self.name = name or f"motor@{bit_start}"
        self._steps_lock = threading.Lock()
        self.steps_taken = 0  # integer microsteps (can be negative historically)
        self._target_lock = threading.Lock()
        self.target_angle_deg = 0.0  # stored as absolute degrees (not steps) but may exceed 360
        self._step_state = 0  # index into seq for which pattern currently on the motor (0..7)

        # start motor thread
        self._stop_event = threading.Event()
        self._thread = threading.Thread(target=self._motor_loop, daemon=True)
        self._thread.start()

    def _current_angle(self):
        # Convert integer steps -> angle (0..360)
        with self._steps_lock:
            ang = (self.steps_taken / Stepper.steps_per_degree) % 360.0
            if ang < 0:
                ang += 360.0
            return ang

    def _write_shifter_nybble(self):
        # Compose the full 8-bit byte and write using the shared lock
        with Stepper.shifter_lock:
            Stepper.shifter_outputs &= ~(0b1111 << self.bit_start)
            Stepper.shifter_outputs |= (Stepper.seq[self._step_state] << self.bit_start)
            self.s.shiftByte(Stepper.shifter_outputs)

    def _step_micro(self, direction):
        # direction: +1 or -1 (one microstep index change)
        self._step_state = (self._step_state + direction) % len(Stepper.seq)
        # write to the shift register
        self._write_shifter_nybble()
        # update integer step counter
        with self._steps_lock:
            self.steps_taken += direction

    def _motor_loop(self):
        # Continuously move towards target angle using shortest-path logic.
        while not self._stop_event.is_set():
            current = self._current_angle()
            with self._target_lock:
                target = self.target_angle_deg  # may be any real number (we normalize below)
            # compute shortest-path delta (in degrees)
            # normalize target to nearest equivalent angle around current:
            desired = target % 360.0
            delta = (desired - current + 180.0) % 360.0 - 180.0  # in (-180,180]
            step_threshold = 1.0 / Stepper.steps_per_degree
            if abs(delta) >= step_threshold:
                direction = 1 if delta > 0 else -1
                self._step_micro(direction)
                # microstep delay
                time.sleep(MOTOR_STEP_DELAY_US / 1e6)
            else:
                time.sleep(0.008)  # idle small sleep to reduce CPU usage

    def goAngle(self, angle_deg):
        """
        Command an absolute angle (in degrees). This method chooses the equivalent angle
        that yields the shortest rotation from the motor's current angle â€” so the motor
        will never Spin > 180 degrees to reach a target.
        angle_deg can be any real number (negative allowed); internally mapped to nearest
        equivalent of that angle relative to current motor position.
        """
        with self._target_lock:
            cur = self._current_angle()
            desired = float(angle_deg) % 360.0
            delta = (desired - cur + 180.0) % 360.0 - 180.0
            # choose target equal to current + delta (this is the nearest equivalent)
            target = cur + delta
            # store the absolute target degree (keeping it within reasonable range)
            self.target_angle_deg = target
        # immediate return; motor thread will move towards target

    def zero(self):
        # make current position read as 0 degrees (but keep internal step_state)
        with self._steps_lock:
            self.steps_taken = 0
        with self._target_lock:
            self.target_angle_deg = 0.0

    def stop(self):
        self._stop_event.set()
        self._thread.join(timeout=1.0)

# ============================================================
# Hardware setup: GPIO, shift register, motors, laser
# ============================================================

GPIO.setmode(GPIO.BCM)

# create the shifter instance (pins may be different on your setup)
s = Shifter(data=16, latch=20, clock=21)

# Create steppers with explicit bit_start:
# Motor 1 (az) uses bits 4..7 -> bit_start = 4
# Motor 2 (el) uses bits 0..3 -> bit_start = 0
m1 = Stepper(s, bit_start=4, name="AZ")  # motor 1 -> AZIMUTH
m2 = Stepper(s, bit_start=0, name="EL")  # motor 2 -> ELEVATION

# Initialize both to zero position (software zero)
m1.zero()
m2.zero()

# Laser setup
GPIO.setup(LASER_PIN, GPIO.OUT, initial=GPIO.LOW)

def laser_on():
    GPIO.output(LASER_PIN, GPIO.HIGH)

def laser_off():
    GPIO.output(LASER_PIN, GPIO.LOW)

laser_off()

# UI state
slider_vals = [0.0, 0.0]   # motor 1 (az), motor 2 (el)
status_lock = threading.Lock()
run_state = {"running": False, "last_error": ""}

# ============================================================
# Geometry helpers
# ============================================================

def polar_to_cartesian(r_cm, theta_rad, z_cm=0.0):
    x = r_cm * math.cos(theta_rad)
    y = r_cm * math.sin(theta_rad)
    z = z_cm
    return x, y, z

def compute_target_angles(my_r, my_theta, target):
    """
    target: dict with keys r (cm), theta (rad), optional z (cm)
    Returns: (azimuth_deg, elevation_deg)
      - azimuth_deg: 0..360 absolute (direction from turret to target)
      - elevation_deg: -90..+90 degrees above horizontal
    """
    tx = float(target["r"])
    ttheta = float(target["theta"])
    tz = float(target.get("z", 0.0))

    my_x, my_y, my_z = polar_to_cartesian(my_r, my_theta, 0.0)
    t_x, t_y, t_z = polar_to_cartesian(tx, ttheta, tz)

    dx = t_x - my_x
    dy = t_y - my_y
    dz = t_z - my_z

    az_rad = math.atan2(dy, dx)
    az_deg = (math.degrees(az_rad)) % 360.0

    horiz = math.hypot(dx, dy)
    el_rad = math.atan2(dz, horiz)
    el_deg = math.degrees(el_rad)  # -90..+90

    return az_deg, el_deg

# ============================================================
# JSON fetching
# ============================================================

def fetch_positions(url, timeout=5.0):
    try:
        with urllib.request.urlopen(url, timeout=timeout) as resp:
            data = resp.read().decode('utf-8')
            return json.loads(data)
    except Exception as e:
        raise RuntimeError(f"Failed to fetch positions.json: {e}")

# ============================================================
# Targeting sequence (threaded runner using m1,m2 objects)
# ============================================================

def run_targeting_sequence_thread():
    with status_lock:
        run_state["running"] = True
        run_state["last_error"] = ""

    try:
        data = fetch_positions(POSITIONS_URL)
    except Exception as e:
        with status_lock:
            run_state["running"] = False
            run_state["last_error"] = str(e)
        print("[ERROR] fetching positions:", e)
        return

    turrets = data.get("turrets", {})
    if str(TEAM_ID) not in turrets:
        err = f"Team {TEAM_ID} not found in positions.json"
        with status_lock:
            run_state["running"] = False
            run_state["last_error"] = err
        print("[ERROR]", err)
        return

    my_entry = turrets[str(TEAM_ID)]
    my_r = float(my_entry["r"])
    my_theta = float(my_entry["theta"])

    targets = []
    # other turrets (z = 0)
    for tid, info in turrets.items():
        if int(tid) == TEAM_ID:
            continue
        targets.append({
            "type": "turret",
            "id": int(tid),
            "r": float(info["r"]),
            "theta": float(info["theta"]),
            "z": 0.0
        })

    # globes
    for gi, g in enumerate(data.get("globes", [])):
        targets.append({
            "type": "globe",
            "id": gi,
            "r": float(g["r"]),
            "theta": float(g["theta"]),
            "z": float(g.get("z", 0.0))
        })

    print(f"[TARGETING] Found {len(targets)} targets.")

    for t in targets:
        az_deg, el_deg = compute_target_angles(my_r, my_theta, t)
        print(f"[TARGET] {t['type']} {t['id']}: az={az_deg:.2f}Â°, el={el_deg:.2f}Â°")

        # Command motors:
        # m1 -> azimuth (0..360)
        m1.goAngle(az_deg)

        # For elevation, m2.goAngle accepts angles in degrees; we pass el_deg directly
        # el_deg is in -90..+90. goAngle will pick the closest equivalent (so it'll move minimal)
        m2.goAngle(el_deg)

        # Wait until motors within tolerance, or timeout
        t0 = time.time()
        timeout = 10.0
        while True:
            cur_az = m1._current_angle()
            cur_el_raw = m2._current_angle()
            # convert raw el into -180..180 for comparison, then into -180..180 centered
            cur_el = ((cur_el_raw + 180.0) % 360.0) - 180.0
            diff_az = (az_deg - cur_az + 180.0) % 360.0 - 180.0
            diff_el = (el_deg - cur_el + 180.0) % 360.0 - 180.0
            if abs(diff_az) <= TARGET_TOLERANCE_DEG and abs(diff_el) <= TARGET_TOLERANCE_DEG:
                break
            if time.time() - t0 > timeout:
                print(f"[WARN] Timeout moving to target az={az_deg:.2f}, el={el_deg:.2f}")
                break
            time.sleep(0.02)

        # Fire laser exactly LASER_FIRE_DURATION seconds
        print("[FIRE] Laser ON")
        laser_on()
        t_fire_start = time.time()
        while time.time() - t_fire_start < LASER_FIRE_DURATION:
            time.sleep(0.01)
        laser_off()
        print("[FIRE] Laser OFF")

    with status_lock:
        run_state["running"] = False
    print("[TARGETING] Sequence complete.")

# ============================================================
# Simple HTML page with manual controls & sequence start
# ============================================================

def html_page():
    with status_lock:
        running = run_state["running"]
        last_err = run_state["last_error"]
    return f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Turret Controller â€” Team {TEAM_ID}</title>
  <style>
    body {{ font-family: Arial; text-align:center; margin-top:20px; }}
    .slider {{ width:360px; margin:12px auto; }}
    input[type=range] {{ width:100%; }}
    button {{ padding:8px 14px; margin:6px; }}
    .status {{ margin-top:12px; }}
  </style>
</head>
<body>
  <h2>IoT Laser Turret â€” Team {TEAM_ID}</h2>

  <div>
    <button onclick="postAction('laser_on')">Laser ON</button>
    <button onclick="postAction('laser_off')">Laser OFF</button>
    <button onclick="postAction('zero')">Zero Motors</button>
    <button onclick="postAction('start_sequence')">Start Targeting Sequence</button>
  </div>

  <div class="slider">
    <label>Motor 1 (Azimuth): <span id="azval">{slider_vals[0]:.1f}</span>Â°</label><br>
    <input id="motor0" type="range" min="0" max="360" value="{slider_vals[0]}" oninput="updateMotor(0)">
  </div>

  <div class="slider">
    <label>Motor 2 (Elevation): <span id="elval">{slider_vals[1]:.1f}</span>Â°</label><br>
    <input id="motor1" type="range" min="-90" max="90" value="{slider_vals[1]}" oninput="updateMotor(1)">
  </div>

  <div class="status">
    <strong>Sequence running:</strong> {running} <br>
    <strong>Last error:</strong> {last_err}
  </div>

<script>
function updateMotor(idx) {{
  let val = document.getElementById("motor"+idx).value;
  if (idx==0) document.getElementById("azval").innerText = val;
  else document.getElementById("elval").innerText = val;
  fetch("/", {{
    method:"POST",
    headers:{{"Content-Type":"application/x-www-form-urlencoded"}},
    body: "motor="+idx+"&level="+val
  }});
}}

function postAction(action) {{
  fetch("/", {{
    method:"POST",
    headers:{{"Content-Type":"application/x-www-form-urlencoded"}},
    body: "action="+action
  }});
}}
</script>
</body>
</html>"""

# ============================================================
# Utility: get local IP (for user to access web UI)
# ============================================================
def get_ip_address():
    sck = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        sck.connect(("8.8.8.8", 80))
        ip = sck.getsockname()[0]
    except:
        ip = "127.0.0.1"
    finally:
        sck.close()
    return ip

# ============================================================
# Simple blocking socket web server (keeps everything single-process)
# ============================================================
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('', 8080))
server.listen(1)

print(f"ðŸš€ Turret UI: http://{get_ip_address()}:8080")
print("Press Ctrl-C to stop and cleanup")

try:
    while True:
        conn, addr = server.accept()
        request = conn.recv(8192).decode(errors='ignore')
        if not request:
            conn.close()
            continue

        # handle POST bodies
        if request.startswith("POST"):
            body = request.split("\r\n\r\n", 1)[-1]
            params = parse_qs(body)

            # slider controls
            if "motor" in params and "level" in params:
                idx = int(params["motor"][0])
                level = float(params["level"][0])
                slider_vals[idx] = level
                if idx == 0:
                    # azimuth: pass 0..360
                    m1.goAngle(level)
                    print(f"[UI] Manual AZ set to {level:.2f}Â°")
                else:
                    # elevation: pass -90..90 (goAngle handles nearest equivalent)
                    m2.goAngle(level)
                    print(f"[UI] Manual EL set to {level:.2f}Â°")

            # action buttons
            if "action" in params:
                action = params["action"][0]
                if action == "laser_on":
                    laser_on()
                    print("[UI] Laser ON (manual)")
                elif action == "laser_off":
                    laser_off()
                    print("[UI] Laser OFF (manual)")
                elif action == "zero":
                    m1.zero(); m2.zero()
                    print("[UI] Motors zeroed (software)")
                elif action == "start_sequence":
                    with status_lock:
                        if run_state["running"]:
                            print("[UI] Sequence already running")
                        else:
                            print("[UI] Starting targeting sequence thread")
                            t = threading.Thread(target=run_targeting_sequence_thread, daemon=True)
                            t.start()

        # Serve page
        response = "HTTP/1.1 200 OK\nContent-Type: text/html\n\n" + html_page()
        conn.sendall(response.encode())
        conn.close()

except KeyboardInterrupt:
    print("\nShutting down...")
    try:
        laser_off()
        # stop motor threads
        m1.stop()
        m2.stop()
    except Exception:
        pass
    GPIO.cleanup()
    server.close()
    sys.exit(0)
