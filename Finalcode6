# ============================================================
#  FULL WEB + SLIDER + STEPPER + JSON TARGETING (Option B)
#  Motor mapping: m1 = AZIMUTH, m2 = ELEVATION
#  TEAM_ID set to 14
# ============================================================

import RPi.GPIO as GPIO
import socket
from urllib.parse import parse_qs
import multiprocessing
import time
from shifter import Shifter
import json
import urllib.request
import math
import threading

# ==================== CONFIG ====================
TEAM_ID = 14                # <-- your team number
POSITIONS_URL = "http://192.168.1.254:8000/positions.json"
LASER_PIN = 18              # BCM pin used to switch laser (via transistor or resistor)
LASER_FIRE_DURATION = 3.0   # seconds laser is on for each firing event
TARGET_TOLERANCE_DEG = 1.0  # consider motor at target when within this many degrees
# =================================================

# ============================================================
#   STEPPER CLASS (Integer-step counting, shortest-path)
# ============================================================

class Stepper:
    num_steppers = 0
    shifter_outputs = 0
    seq = [0b0001, 0b0011, 0b0010, 0b0110, 0b0100, 0b1100, 0b1000, 0b1001]
    delay = 1200
    steps_per_degree = 4096.0 / 360.0  # steps per degree (float)

    def __init__(self, shifter, lock):
        self.s = shifter
        self.lock = lock  # lock to prevent race conditions
        self.steps_taken = multiprocessing.Value('i', 0)  # track absolute integer steps
        self.target_angle = multiprocessing.Value('d', 0.0)

        # Give each motor a unique starting phase
        self.step_state = Stepper.num_steppers % 8

        # Map first created Stepper -> bits 0-3, second -> 4-7
        self.shifter_bit_start = 4 * Stepper.num_steppers

        Stepper.num_steppers += 1

        # start background process
        self.process = multiprocessing.Process(target=self._motor_loop)
        self.process.daemon = True
        self.process.start()

    def _current_angle(self):
        with self.steps_taken.get_lock():
            ang = (self.steps_taken.value / Stepper.steps_per_degree) % 360.0
            if ang < 0:
                ang += 360.0
            return ang

    def _step(self, direction):
        self.step_state = (self.step_state + direction) % 8

        # update shift register safely
        with self.lock:
            Stepper.shifter_outputs &= ~(0b1111 << self.shifter_bit_start)
            Stepper.shifter_outputs |= (Stepper.seq[self.step_state] << self.shifter_bit_start)
            self.s.shiftByte(Stepper.shifter_outputs)

        # increment integer steps
        with self.steps_taken.get_lock():
            self.steps_taken.value += direction

    def _motor_loop(self):
        while True:
            current = self._current_angle()
            with self.target_angle.get_lock():
                target = self.target_angle.value

            # shortest-path delta in degrees
            delta_deg = (target - current + 180.0) % 360.0 - 180.0
            step_threshold = 1.0 / Stepper.steps_per_degree
            if abs(delta_deg) >= (step_threshold):
                direction = 1 if delta_deg > 0 else -1
                self._step(direction)
                time.sleep(Stepper.delay / 1e6)
            else:
                time.sleep(0.01)

    def goAngle(self, angle_deg):
        """Set absolute target angle in degrees (0-360)."""
        with self.target_angle.get_lock():
            self.target_angle.value = angle_deg % 360.0

    def zero(self):
        """Set current step count to represent 0 degrees; keep phase."""
        with self.steps_taken.get_lock():
            self.steps_taken.value = 0
        with self.target_angle.get_lock():
            self.target_angle.value = 0.0

# ============================================================
#   SETUP SHIFT REGISTER + MOTORS + LASER GPIO
# ============================================================

GPIO.setmode(GPIO.BCM)

# Initialize shifter (use your pins)
s = Shifter(data=16, latch=20, clock=21)
lock = multiprocessing.Lock()

m1 = Stepper(s, lock)  # motor 1 -> AZIMUTH
m2 = Stepper(s, lock)  # motor 2 -> ELEVATION

m1.zero()
m2.zero()

# Laser output pin setup
GPIO.setup(LASER_PIN, GPIO.OUT, initial=GPIO.LOW)

def laser_on():
    GPIO.output(LASER_PIN, GPIO.HIGH)

def laser_off():
    GPIO.output(LASER_PIN, GPIO.LOW)

laser_off()

# Shared UI values (simple local state)
slider_vals = [0.0, 0.0]  # degrees for UI display
status_lock = threading.Lock()
run_state = {"running": False, "last_error": ""}

# ============================================================
#   GEOMETRY: polar->cartesian and angle computations
# ============================================================

def polar_to_cartesian(r_cm, theta_rad, z_cm=0.0):
    x = r_cm * math.cos(theta_rad)
    y = r_cm * math.sin(theta_rad)
    z = z_cm
    return x, y, z

def compute_target_angles(my_r, my_theta, target):
    """
    target: dict with r (cm), theta (rad), optionally z (cm)
    returns (azimuth_deg, elevation_deg)
    azimuth_deg in 0..360, elevation_deg in -90..+90
    """
    tx = float(target["r"])
    ttheta = float(target["theta"])
    tz = float(target.get("z", 0.0))

    my_x, my_y, my_z = polar_to_cartesian(my_r, my_theta, 0.0)
    t_x, t_y, t_z = polar_to_cartesian(tx, ttheta, tz)

    dx = t_x - my_x
    dy = t_y - my_y
    dz = t_z - my_z

    azimuth_rad = math.atan2(dy, dx)
    azimuth_deg = math.degrees(azimuth_rad) % 360.0

    horizontal_dist = math.hypot(dx, dy)
    elevation_rad = math.atan2(dz, horizontal_dist)
    elevation_deg = math.degrees(elevation_rad)

    return azimuth_deg, elevation_deg

# ============================================================
#   JSON fetching
# ============================================================

def fetch_positions(url, timeout=5.0):
    try:
        with urllib.request.urlopen(url, timeout=timeout) as resp:
            data = resp.read().decode('utf-8')
            return json.loads(data)
    except Exception as e:
        raise RuntimeError(f"Failed to fetch positions.json: {e}")

# ============================================================
#   TARGETING SEQUENCE (threaded runner)
# ============================================================

def run_targeting_sequence_thread():
    with status_lock:
        run_state["running"] = True
        run_state["last_error"] = ""

    try:
        data = fetch_positions(POSITIONS_URL)
    except Exception as e:
        with status_lock:
            run_state["running"] = False
            run_state["last_error"] = str(e)
        print("Error fetching positions:", e)
        return

    turrets = data.get("turrets", {})
    if str(TEAM_ID) not in turrets:
        err = f"Team {TEAM_ID} not found in positions.json"
        with status_lock:
            run_state["running"] = False
            run_state["last_error"] = err
        print(err)
        return

    my_entry = turrets[str(TEAM_ID)]
    my_r = float(my_entry["r"])
    my_theta = float(my_entry["theta"])

    # Build target list: other turrets (exclude self) and globes
    targets = []
    for tid, info in turrets.items():
        if int(tid) == TEAM_ID:
            continue
        targets.append({
            "type": "turret",
            "id": int(tid),
            "r": float(info["r"]),
            "theta": float(info["theta"]),
            "z": 0.0
        })

    globes = data.get("globes", [])
    for gi, g in enumerate(globes):
        targets.append({
            "type": "globe",
            "id": gi,
            "r": float(g["r"]),
            "theta": float(g["theta"]),
            "z": float(g["z"])
        })

    print(f"[TARGETING] {len(targets)} targets found.")

    for t in targets:
        az_deg, el_deg = compute_target_angles(my_r, my_theta, t)
        print(f"[TARGET] {t['type']} {t['id']}: az={az_deg:.2f}Â°, el={el_deg:.2f}Â°")

        # Command motors (m1 -> azimuth, m2 -> elevation)
        m1.goAngle(az_deg)
        # convert elevation (-90..90) to a 0..360 motor angle if needed:
        # We will map elevation into 0..360 such that motor's zero=0deg horizontal,
        # positive elevation is a positive motor rotation from that zero.
        # If your elevation motor expects a different range, adapt here.
        m2_target = (el_deg + 360.0) % 360.0
        m2.goAngle(m2_target)

        # Wait until target reached or timeout
        start_wait = time.time()
        timeout = 10.0
        while True:
            cur_az = m1._current_angle()
            cur_el_raw = m2._current_angle()
            # convert raw el motor angle back to -180..180 centered
            cur_el = ((cur_el_raw + 180.0) % 360.0) - 180.0
            diff_az = (az_deg - cur_az + 180.0) % 360.0 - 180.0
            diff_el = (el_deg - cur_el + 180.0) % 360.0 - 180.0
            if abs(diff_az) <= TARGET_TOLERANCE_DEG and abs(diff_el) <= TARGET_TOLERANCE_DEG:
                break
            if time.time() - start_wait > timeout:
                print(f"[WARN] Motor timeout reaching target az={az_deg:.2f}, el={el_deg:.2f}")
                break
            time.sleep(0.02)

        # Fire laser exactly LASER_FIRE_DURATION seconds
        print("[FIRE] Laser ON")
        laser_on()
        t0 = time.time()
        while time.time() - t0 < LASER_FIRE_DURATION:
            time.sleep(0.01)
        laser_off()
        print("[FIRE] Laser OFF")

    with status_lock:
        run_state["running"] = False
    print("[TARGETING] Sequence complete.")

# ============================================================
#   HTML PAGE (buttons + sliders)
# ============================================================

def html_page():
    with status_lock:
        running = run_state["running"]
        last_err = run_state["last_error"]
    return f"""<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>Turret Controller - Team {TEAM_ID}</title>
<style>
  body {{ font-family: Arial; text-align: center; margin-top: 20px; }}
  .slider-container {{ margin: 15px auto; width: 360px; }}
  input[type=range] {{ width: 100%; }}
  button {{ padding: 8px 14px; margin: 6px; }}
  .status {{ margin-top: 12px; color: #333; }}
</style></head>
<body>
<h2>IoT Laser Turret â€” Team {TEAM_ID}</h2>

<div>
  <button onclick="postAction('laser_on')">Laser ON</button>
  <button onclick="postAction('laser_off')">Laser OFF</button>
  <button onclick="postAction('zero')">Zero Motors</button>
  <button onclick="postAction('start_sequence')">Start Targeting Sequence</button>
</div>

<div class="slider-container">
  <label>Motor 1 (Azimuth) â€” {slider_vals[0]:.1f}Â°</label><br>
  <input type="range" min="0" max="360" value="{slider_vals[0]}" id="motor0" oninput="updateMotor(0)">
  <span id="val0">{slider_vals[0]}</span>
</div>

<div class="slider-container">
  <label>Motor 2 (Elevation) â€” {slider_vals[1]:.1f}Â°</label><br>
  <input type="range" min="-90" max="90" value="{slider_vals[1]}" id="motor1" oninput="updateMotor(1)">
  <span id="val1">{slider_vals[1]}</span>
</div>

<div class="status">
  <strong>Sequence running:</strong> {running} <br>
  <strong>Last error:</strong> {last_err}
</div>

<script>
function updateMotor(idx) {{
    let val = document.getElementById("motor" + idx).value;
    document.getElementById("val" + idx).innerHTML = val;
    fetch("/", {{
      method: "POST",
      headers: {{ "Content-Type": "application/x-www-form-urlencoded" }},
      body: "motor=" + idx + "&level=" + val
    }});
}}

function postAction(action) {{
    fetch("/", {{
      method: "POST",
      headers: {{ "Content-Type": "application/x-www-form-urlencoded" }},
      body: "action=" + action
    }});
}}
</script>

</body></html>"""

# ============================================================
#   GET IP ADDRESS
# ============================================================

def get_ip_address():
    sck = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        sck.connect(("8.8.8.8", 80))
        ip = sck.getsockname()[0]
    except:
        ip = "127.0.0.1"
    finally:
        sck.close()
    return ip

# ============================================================
#   WEB SERVER LOOP
# ============================================================

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('', 8080))
server.listen(1)

print(f"ðŸŒ Control turret at: http://{get_ip_address()}:8080")

try:
    while True:
        conn, addr = server.accept()
        request = conn.recv(4096).decode(errors="ignore")
        if not request:
            conn.close()
            continue

        if "POST" in request.splitlines()[0]:
            body = request.split("\r\n\r\n", 1)[-1]
            params = parse_qs(body)

            if "motor" in params and "level" in params:
                idx = int(params["motor"][0])
                level = float(params["level"][0])
                slider_vals[idx] = level

                if idx == 0:
                    # azimuth slider uses 0..360 directly
                    motor_target = level % 360.0
                    m1.goAngle(motor_target)
                else:
                    # elevation slider gives -90..90; map to motor angle space
                    # here we map elevation e (-90..90) -> motor angle (e mod 360)
                    # adjust mapping if your elevation motor zero differs physically
                    motor_target = (level + 360.0) % 360.0
                    m2.goAngle(motor_target)
                print(f"Manual: Motor {idx+1} â†’ {level:.2f}")

            if "action" in params:
                action = params["action"][0]
                if action == "laser_on":
                    laser_on(); print("Laser ON (manual)")
                elif action == "laser_off":
                    laser_off(); print("Laser OFF (manual)")
                elif action == "zero":
                    m1.zero(); m2.zero(); print("Motors zeroed")
                elif action == "start_sequence":
                    with status_lock:
                        if run_state["running"]:
                            print("Sequence already running")
                        else:
                            print("Starting targeting sequence")
                            t = threading.Thread(target=run_targeting_sequence_thread, daemon=True)
                            t.start()

        response = "HTTP/1.1 200 OK\nContent-Type: text/html\n\n" + html_page()
        conn.sendall(response.encode())
        conn.close()

except KeyboardInterrupt:
    print("\nShutting Down...")
    laser_off()
    GPIO.cleanup()
    server.close()
