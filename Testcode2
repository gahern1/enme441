#!/usr/bin/env python3
# ============================================================
# IoT Laser Turret — Full Ready-to-Run (Stable EL, AZ Shortest-Path)
# ============================================================

import RPi.GPIO as GPIO
import socket
from urllib.parse import parse_qs
import time
from shifter import Shifter
import math
import threading
import sys

# ==================== CONFIG ====================
TEAM_ID = 14
LASER_PIN = 18
LASER_FIRE_DURATION = 3.0
TARGET_TOLERANCE_DEG = 1.0
MOTOR_STEP_DELAY_US = 1200
LASER_HEIGHT_CM = 3.25
EL_INITIAL_ANGLE = 0.0
# =================================================

# ============================================================
# Stepper class
# ============================================================

class Stepper:
    seq = [0b0001, 0b0011, 0b0010, 0b0110, 0b0100, 0b1100, 0b1000, 0b1001]
    steps_per_degree = 4096.0 / 360.0
    shifter_outputs = 0
    shifter_lock = threading.Lock()

    def __init__(self, shifter, bit_start, name=""):
        self.s = shifter
        self.bit_start = int(bit_start)
        self.name = name or f"motor@{bit_start}"
        self._steps_lock = threading.Lock()
        self.steps_taken = 0
        self._target_lock = threading.Lock()
        self.target_angle_deg = 0.0
        self._step_state = 0
        self._stop_event = threading.Event()
        self._physical_zero_angle = EL_INITIAL_ANGLE if self.name == "EL" else 0.0
        self._init_offset = 0.0
        self._thread = threading.Thread(target=self._motor_loop, daemon=True)
        self._thread.start()

    def _current_angle(self):
        with self._steps_lock:
            if self.name == "EL":
                # Track EL strictly, no flip in reporting
                ang = self._physical_zero_angle + self.steps_taken / Stepper.steps_per_degree + self._init_offset
                return max(-90.0, min(90.0, ang))
            else:
                # AZ normal
                return self.steps_taken / Stepper.steps_per_degree

    def _write_shifter_nybble(self):
        with Stepper.shifter_lock:
            Stepper.shifter_outputs &= ~(0b1111 << self.bit_start)
            Stepper.shifter_outputs |= (Stepper.seq[self._step_state] << self.bit_start)
            self.s.shiftByte(Stepper.shifter_outputs)

    def _step_micro(self, direction):
        # Only physically flip EL direction for wiring
        step_dir = -direction if self.name == "EL" else direction
        self._step_state = (self._step_state + step_dir) % len(Stepper.seq)
        self._write_shifter_nybble()
        with self._steps_lock:
            self.steps_taken += direction  # always accumulate real logical delta

    def _motor_loop(self):
        while not self._stop_event.is_set():
            current = self._current_angle()
            with self._target_lock:
                target = self.target_angle_deg
            # Clamp EL
            if self.name == "EL":
                target = max(-90.0, min(90.0, target))
            # Compute delta
            delta = (target - current + 180.0) % 360.0 - 180.0 if self.name != "EL" else target - current
            step_threshold = 1.0 / Stepper.steps_per_degree
            if abs(delta) >= step_threshold:
                direction = 1 if delta > 0 else -1
                self._step_micro(direction)
                time.sleep(MOTOR_STEP_DELAY_US / 1e6)
            else:
                time.sleep(0.008)

    def goAngle(self, angle_deg):
        with self._target_lock:
            if self.name == "EL":
                angle_deg = max(-90.0, min(90.0, angle_deg))
            self.target_angle_deg = angle_deg

    def zero(self, init_angle=0.0):
        with self._steps_lock:
            if self.name == "EL":
                self._physical_zero_angle = init_angle
                self._init_offset = 0.0
                self.steps_taken = 0
            else:
                self.steps_taken = 0
        with self._target_lock:
            self.target_angle_deg = init_angle

    def stop(self):
        self._stop_event.set()
        self._thread.join(timeout=1.0)

# ============================================================
# Hardware setup
# ============================================================

GPIO.setmode(GPIO.BCM)
s = Shifter(data=16, latch=20, clock=21)

m1 = Stepper(s, bit_start=4, name="EL")
m2 = Stepper(s, bit_start=0, name="AZ")
m1.zero(init_angle=EL_INITIAL_ANGLE)
m2.zero()

GPIO.setup(LASER_PIN, GPIO.OUT, initial=GPIO.LOW)
def laser_on(): GPIO.output(LASER_PIN, GPIO.HIGH)
def laser_off(): GPIO.output(LASER_PIN, GPIO.LOW)
laser_off()

slider_vals = [EL_INITIAL_ANGLE, 0.0]
status_lock = threading.Lock()
run_state = {"running": False, "last_error": ""}

# ============================================================
# Hardcoded positions
# ============================================================

TURRETS = { ... }  # same as previous code
GLOBES = [ ... ]   # same as previous code

# ============================================================
# Geometry helpers
# ============================================================

def polar_to_cartesian(r_cm, theta_rad, z_cm=0.0):
    x = r_cm * math.cos(theta_rad)
    y = r_cm * math.sin(theta_rad)
    z = z_cm
    return x, y, z

def compute_target_angles(my_r, my_theta, my_z, target):
    tx = float(target["r"])
    ttheta = float(target["theta"])
    tz = float(target.get("z", 0.0))
    my_x, my_y, my_z = polar_to_cartesian(my_r, my_theta, my_z)
    t_x, t_y, t_z = polar_to_cartesian(tx, ttheta, tz)
    dx = t_x - my_x
    dy = t_y - my_y
    dz = t_z - my_z
    az_rad = math.atan2(dy, dx)
    az_deg = (math.degrees(az_rad)) % 360.0
    horiz = math.hypot(dx, dy)
    el_rad = math.atan2(dz, horiz)
    el_deg = math.degrees(el_rad)
    return az_deg, el_deg

# ============================================================
# Targeting sequence (same as previous, uses compute_target_angles)
# ============================================================

def run_targeting_sequence_thread():
    my_entry = TURRETS[TEAM_ID]
    my_r = float(my_entry["r"])
    my_theta = float(my_entry["theta"])
    my_z = LASER_HEIGHT_CM

    targets = []
    for tid, info in TURRETS.items():
        if tid == TEAM_ID: continue
        targets.append({"type":"turret","id":tid,"r":float(info["r"]),"theta":float(info["theta"]),"z":0.0})
    for gi, g in enumerate(GLOBES):
        targets.append({"type":"globe","id":gi,"r":float(g["r"]),"theta":float(g["theta"]),"z":float(g["z"])})

    with status_lock:
        run_state["running"] = True
        run_state["last_error"] = ""

    print(f"[TARGETING] Found {len(targets)} targets.")
    for t in targets:
        az_deg, el_deg = compute_target_angles(my_r, my_theta, my_z, t)
        print(f"[TARGET] {t['type']} {t['id']}: az={az_deg:.2f}°, el={el_deg:.2f}°")
        m2.goAngle(az_deg)
        m1.goAngle(el_deg)
        t0 = time.time()
        timeout = 10.0
        while True:
            cur_az = m2._current_angle()
            cur_el = m1._current_angle()
            diff_az = (az_deg - cur_az + 180.0) % 360.0 - 180.0
            diff_el = el_deg - cur_el
            if abs(diff_az) <= TARGET_TOLERANCE_DEG and abs(diff_el) <= TARGET_TOLERANCE_DEG:
                break
            if time.time() - t0 > timeout:
                print(f"[WARN] Timeout moving to target az={az_deg:.2f}, el={el_deg:.2f}°")
                break
            time.sleep(0.02)
        print("[FIRE] Laser ON")
        laser_on()
        t_fire_start = time.time()
        while time.time() - t_fire_start < LASER_FIRE_DURATION:
            time.sleep(0.01)
        laser_off()
        print("[FIRE] Laser OFF")

    with status_lock:
        run_state["running"] = False
    print("[TARGETING] Sequence complete.")

# ============================================================
# HTML UI & Webserver unchanged
# ============================================================

# ... (same as previous code)
