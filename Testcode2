#!/usr/bin/env python3
# ============================================================
# IoT Laser Turret — AZ/EL Swap Corrected
# - Motor 1 (EL) -> shift register bits 4-7 (inverted)
# - Motor 2 (AZ) -> shift register bits 0-3
# - Threaded motor loops
# - goAngle uses shortest-path immediately
# - Hardcoded positions (no JSON)
# - Laser height incorporated
# - Physical zero for EL to prevent startup flip
# ============================================================

import RPi.GPIO as GPIO
import socket
from urllib.parse import parse_qs
import time
from shifter import Shifter
import math
import threading
import sys

# ==================== CONFIG ====================
TEAM_ID = 14
LASER_PIN = 18
LASER_FIRE_DURATION = 3.0
TARGET_TOLERANCE_DEG = 1.0
MOTOR_STEP_DELAY_US = 1200
LASER_HEIGHT_CM = 3.25   # Laser height above ground
EL_INITIAL_ANGLE = 0.0   # Horizontal at startup
# =================================================

# ============================================================
# Stepper class
# ============================================================

class Stepper:
    seq = [0b0001, 0b0011, 0b0010, 0b0110, 0b0100, 0b1100, 0b1000, 0b1001]
    steps_per_degree = 4096.0 / 360.0
    shifter_outputs = 0
    shifter_lock = threading.Lock()

    def __init__(self, shifter, bit_start, name=""):
        self.s = shifter
        self.bit_start = int(bit_start)
        self.name = name or f"motor@{bit_start}"
        self._steps_lock = threading.Lock()
        self.steps_taken = 0
        self._target_lock = threading.Lock()
        self.target_angle_deg = 0.0
        self._step_state = 0
        self._stop_event = threading.Event()
        # EL motor: track physical zero to avoid flip
        self._physical_zero_angle = EL_INITIAL_ANGLE if self.name == "EL" else 0.0
        self._init_offset = 0.0
        self._thread = threading.Thread(target=self._motor_loop, daemon=True)
        self._thread.start()

    def _current_angle(self):
        with self._steps_lock:
            ang = (self.steps_taken / Stepper.steps_per_degree) % 360.0
            if self.name == "EL":
                ang = (self._physical_zero_angle + ang + self._init_offset) % 360.0
            if ang < 0:
                ang += 360.0
            return ang

    def _write_shifter_nybble(self):
        with Stepper.shifter_lock:
            Stepper.shifter_outputs &= ~(0b1111 << self.bit_start)
            Stepper.shifter_outputs |= (Stepper.seq[self._step_state] << self.bit_start)
            self.s.shiftByte(Stepper.shifter_outputs)

    def _step_micro(self, direction):
        # Invert EL motion for intuitive up
        if self.name == "EL":
            direction = -direction
        self._step_state = (self._step_state + direction) % len(Stepper.seq)
        self._write_shifter_nybble()
        with self._steps_lock:
            self.steps_taken += direction

    def _motor_loop(self):
        while not self._stop_event.is_set():
            current = self._current_angle()
            with self._target_lock:
                target = self.target_angle_deg
            desired = target % 360.0
            delta = (desired - current + 180.0) % 360.0 - 180.0
            step_threshold = 1.0 / Stepper.steps_per_degree
            if abs(delta) >= step_threshold:
                direction = 1 if delta > 0 else -1
                self._step_micro(direction)
                time.sleep(MOTOR_STEP_DELAY_US / 1e6)
            else:
                time.sleep(0.008)

    def goAngle(self, angle_deg):
        with self._target_lock:
            cur = self._current_angle()
            desired = float(angle_deg) % 360.0
            delta = (desired - cur + 180.0) % 360.0 - 180.0
            self.target_angle_deg = cur + delta

    def zero(self, init_angle=0.0):
        with self._steps_lock:
            if self.name == "EL":
                self._physical_zero_angle = init_angle
                self._init_offset = 0.0
                self.steps_taken = 0
            else:
                self.steps_taken = 0
        with self._target_lock:
            self.target_angle_deg = init_angle

    def stop(self):
        self._stop_event.set()
        self._thread.join(timeout=1.0)

# ============================================================
# Hardware setup
# ============================================================

GPIO.setmode(GPIO.BCM)
s = Shifter(data=16, latch=20, clock=21)

m1 = Stepper(s, bit_start=4, name="EL")   # Elevation
m2 = Stepper(s, bit_start=0, name="AZ")   # Azimuth
m1.zero(init_angle=EL_INITIAL_ANGLE)
m2.zero()

GPIO.setup(LASER_PIN, GPIO.OUT, initial=GPIO.LOW)
def laser_on(): GPIO.output(LASER_PIN, GPIO.HIGH)
def laser_off(): GPIO.output(LASER_PIN, GPIO.LOW)
laser_off()

slider_vals = [EL_INITIAL_ANGLE, 0.0]
status_lock = threading.Lock()
run_state = {"running": False, "last_error": ""}

# ============================================================
# Hardcoded positions
# ============================================================

TURRETS = {
    1:  {"r": 154.305, "theta": 2.775},
    2:  {"r": 154.305, "theta": 2.251},
    3:  {"r": 154.305, "theta": 1.972},
    4:  {"r": 154.305, "theta": 1.344},
    5:  {"r": 154.305, "theta": 4.520},
    6:  {"r": 154.305, "theta": 5.760},
    7:  {"r": 154.305, "theta": 4.974},
    8:  {"r": 154.305, "theta": 3.246},
    9:  {"r": 154.305, "theta": 3.665},
    10: {"r": 154.305, "theta": 5.288},
    11: {"r": 154.305, "theta": 4.189},
    12: {"r": 154.305, "theta": 0.681},
    13: {"r": 154.305, "theta": 0.314},
    14: {"r": 154.305, "theta": 1.100},  # Your turret
    15: {"r": 154.305, "theta": 2.443},
    16: {"r": 154.305, "theta": 1.553},
    17: {"r": 154.305, "theta": 6.039},
    18: {"r": 154.305, "theta": 0.122},
    19: {"r": 154.305, "theta": 0.855},
    20: {"r": 154.305, "theta": 4.747},
    21: {"r": 154.305, "theta": 5.568},
    22: {"r": 154.305, "theta": 3.054}
}

GLOBES = [
    {"r": 154.305, "theta": 5.952, "z": 77.0},
    {"r": 154.305, "theta": 6.248, "z": 22.0},
    {"r": 154.305, "theta": 1.309, "z": 93.0},
    {"r": 154.305, "theta": 2.618, "z": 154.0},
    {"r": 154.305, "theta": 3.665, "z": 58.0},
    {"r": 154.305, "theta": 3.107, "z": 163.0},
    {"r": 154.305, "theta": 4.259, "z": 81.0},
    {"r": 154.305, "theta": 4.032, "z": 19.0}
]

# ============================================================
# Geometry helpers
# ============================================================

def polar_to_cartesian(r_cm, theta_rad, z_cm=0.0):
    x = r_cm * math.cos(theta_rad)
    y = r_cm * math.sin(theta_rad)
    z = z_cm
    return x, y, z

def compute_target_angles(my_r, my_theta, my_z, target):
    tx = float(target["r"])
    ttheta = float(target["theta"])
    tz = float(target.get("z", 0.0))
    my_x, my_y, my_z = polar_to_cartesian(my_r, my_theta, my_z)
    t_x, t_y, t_z = polar_to_cartesian(tx, ttheta, tz)
    dx = t_x - my_x
    dy = t_y - my_y
    dz = t_z - my_z
    az_rad = math.atan2(dy, dx)
    az_deg = (math.degrees(az_rad)) % 360.0
    horiz = math.hypot(dx, dy)
    el_rad = math.atan2(dz, horiz)
    el_deg = math.degrees(el_rad)
    return az_deg, el_deg

# ============================================================
# Targeting sequence
# ============================================================

def run_targeting_sequence_thread():
    with status_lock:
        run_state["running"] = True
        run_state["last_error"] = ""

    my_entry = TURRETS[TEAM_ID]
    my_r = float(my_entry["r"])
    my_theta = float(my_entry["theta"])
    my_z = LASER_HEIGHT_CM

    # Collect targets
    targets = []
    for tid, info in TURRETS.items():
        if tid == TEAM_ID:
            continue
        targets.append({"type": "turret", "id": tid, "r": float(info["r"]), "theta": float(info["theta"]), "z": 0.0})
    for gi, g in enumerate(GLOBES):
        targets.append({"type": "globe", "id": gi, "r": float(g["r"]), "theta": float(g["theta"]), "z": float(g["z"])})

    print(f"[TARGETING] Found {len(targets)} targets.")

    for t in targets:
        az_deg, el_deg = compute_target_angles(my_r, my_theta, my_z, t)
        print(f"[TARGET] {t['type']} {t['id']}: az={az_deg:.2f}°, el={el_deg:.2f}°")
        m2.goAngle(az_deg)  # AZ = m2
        m1.goAngle(el_deg)  # EL = m1
        t0 = time.time()
        timeout = 10.0
        while True:
            cur_az = m2._current_angle()
            cur_el_raw = m1._current_angle()
            cur_el = ((cur_el_raw + 180.0) % 360.0) - 180.0
            diff_az = (az_deg - cur_az + 180.0) % 360.0 - 180.0
            diff_el = (el_deg - cur_el + 180.0) % 360.0 - 180.0
            if abs(diff_az) <= TARGET_TOLERANCE_DEG and abs(diff_el) <= TARGET_TOLERANCE_DEG:
                break
            if time.time() - t0 > timeout:
                print(f"[WARN] Timeout moving to target az={az_deg:.2f}, el={el_deg:.2f}°")
                break
            time.sleep(0.02)
        print("[FIRE] Laser ON")
        laser_on()
        t_fire_start = time.time()
        while time.time() - t_fire_start < LASER_FIRE_DURATION:
            time.sleep(0.01)
        laser_off()
        print("[FIRE] Laser OFF")

    with status_lock:
        run_state["running"] = False
    print("[TARGETING] Sequence complete.")

# ============================================================
# UI and server code remains unchanged
# ============================================================

# (Copy the HTML UI and server code from previous version; no changes)
